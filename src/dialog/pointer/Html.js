require("../../__init.js");
require("metaphorjs/src/func/dom/setStyle.js");
require("metaphorjs/src/func/dom/addClass.js");
require("metaphorjs-animate/src/animate/getPrefixes.js");
require("./Abstract.js");

var MetaphorJs = require("metaphorjs-shared/src/MetaphorJs.js"),
    ucfirst = require("metaphorjs-shared/src/func/ucfirst.js");

module.exports = MetaphorJs.dialog.pointer.Html = (function(){

    var ie6             = null,
        defaultProps    = {
            backgroundColor: 'transparent',
            width: 			'0px',
            height: 		'0px',
            position: 		'absolute',
            fontSize: 	    '0px', // ie6
            lineHeight:     '0px' // ie6
        };

    return MetaphorJs.dialog.pointer.Abstract.$extend({

        node: null,
        sub: null,

        $init: function(dialog, cfg) {

            if (ie6 === null) {
                ie6 = window.document.all && !window.XMLHttpRequest
            }

            var self = this;

            self.$super(dialog, cfg);

            self.width = self.width || self.size * 2;

            if (self.inner) {
                self.enabled = true;
            }
        },



        createInner: function() {
            var self        = this,
                newcfg 		= extend({}, self.origCfg);

            newcfg.size 	= self.size - (self.border * 2);
            newcfg.width	= self.width - (self.border * 4);

            newcfg.border = 0;
            newcfg.borderColor = null;
            newcfg.borderCls = null;
            newcfg.offset = 0;
            newcfg.inner = self.border;

            self.sub = new MetaphorJs.dialog.pointer.Html(self.dialog, newcfg);
        },


        getBorders: function(position, direction, color) {

            var self        = this,
                borders 	= {},
                pri 		= position.substr(0,1),
                dpri        = direction.substr(0,1),
                dsec        = direction.substr(1),
                style       = ie6 ? "dotted" : "solid",
                names       = self.names,
                sides       = self.sides,
                opposite    = self.opposite;

            // in ie6 "solid" wouldn't make transparency :(

            // this is always height : border which is opposite to direction
            borders['border'+ucfirst(names[opposite[pri]])] = self.size + "px solid "+color;
            // border which is similar to direction is always 0
            borders['border'+ucfirst(names[pri])] = "0 "+style+" transparent";

            if (!dsec) {
                // if pointer's direction matches pointer primary position (p: l|lt|lb, d: l)
                // then we set both side borders to a half of the width;
                var side = Math.floor(self.width / 2);
                borders['border' + ucfirst(names[sides[dpri][0]])] = side + "px "+style+" transparent";
                borders['border' + ucfirst(names[sides[dpri][1]])] = side + "px "+style+" transparent";
            }
            else {
                // if pointer's direction doesn't match with primary position (p: l|lt|lb, d: t|b)
                // we set the border opposite to direction to the full width;
                borders['border'+ucfirst(names[dsec])] = "0 solid transparent";
                borders['border'+ucfirst(names[opposite[dsec]])] = self.width + "px "+style+" transparent";
            }

            return borders;
        },

        getOffsets: function(position, direction) {

            var self    = this,
                offsets = {},
                names   = self.names,
                opposite= self.opposite,
                pri		= position.substr(0,1),
                auto 	= (pri == 't' || pri == 'b') ? "r" : "b";

            offsets[names[pri]] = self.inner ? 'auto' : -self.size+"px";
            offsets[names[auto]] = "auto";

            if (!self.inner) {

                var margin;

                switch (position) {
                    case 't': case 'r': case 'b': case 'l':
                        if (direction != position) {
                            if (direction == 'l' || direction == 't') {
                                margin = self.offset;
                            }
                            else {
                                margin = -self.width + self.offset;
                            }
                        }
                        else {
                            margin = -self.width/2 + self.offset;
                        }
                        break;

                    case 'bl': case 'tl': case 'lt': case 'rt':
                        margin = self.offset;
                        break;

                    default:
                        margin = -self.width - self.offset;
                        break;
                }

                offsets['margin' + ucfirst(names[opposite[auto]])] = margin + "px";

                var positionOffset;

                switch (position) {
                    case 't': case 'r': case 'b': case 'l':
                        positionOffset = '50%';
                        break;

                    case 'tr': case 'rb': case 'br': case 'lb':
                        positionOffset = '100%';
                        break;

                    default:
                        positionOffset = 0;
                        break;
                }

                offsets[names[opposite[auto]]]  = positionOffset;

                var pfxs = MetaphorJs.animate.getPrefixes(),
                    transformPfx = pfxs.transform,
                    transform = "",
                    cx = self.correctX,
                    cy = self.correctY;

                if (transformPfx) {

                    if (cx) {
                        transform += " translateX(" + self.getCorrectionValue("x", cx, position) + "px)";
                    }
                    if (cy) {
                        transform += " translateY(" + self.getCorrectionValue("y", cy, position) + "px)";
                    }

                    offsets[transformPfx] = transform;
                }
            }
            else {

                var innerOffset,
                    dpri    = direction.substr(0, 1),
                    dsec    = direction.substr(1);

                if (dsec) {
                    if (dsec == 'l' || dsec == 't') {
                        innerOffset = self.inner + 'px';
                    }
                    else {
                        innerOffset = -self.width - self.inner + 'px';
                    }
                }
                else {
                    innerOffset = Math.floor(-self.width / 2) + 'px';
                }

                offsets[names[opposite[auto]]]  = innerOffset;
                offsets[names[opposite[dpri]]] = -(self.size + (self.inner * 2)) + 'px';
            }


            return offsets;
        },

        render: function() {

            var self = this;

            if (!self.enabled) {
                return;
            }

            if (self.node) {
                return;
            }

            var position    = self.detectPointerPosition();
            if (!position) {
                return;
            }

            if (self.border && !self.sub) {
                self.createInner();
            }

            self.node   = window.document.createElement('div');
            var cmt     = window.document.createComment(" ");

            self.node.appendChild(cmt);

            setStyle(self.node, defaultProps);
            MetaphorJs.dom.addClass(self.node, self.borderCls || self.cls);

            if (self.sub) {
                self.sub.render();
                self.node.appendChild(self.sub.getElem());
            }
        },

        reposition: function() {

            var self        = this,
                position    = self.detectPointerPosition(),
                direction   = self.detectPointerDirection(position);

            if (!self.node) {
                return;
            }

            MetaphorJs.dom.setStyle(self.node, 
                self.getBorders(position, direction, self.borderColor || self.color));
            MetaphorJs.dom.setStyle(self.node, 
                self.getOffsets(position, direction));

            if (self.sub) {
                self.sub.reposition();
            }
        },

        update: function() {
            var self = this;
            if (self.sub) {
                self.sub.$destroy();
                self.sub = null;
            }
            self.remove();
            self.node = null;
            self.render();
            self.append();

            if (self.dialog.isVisible()) {
                self.dialog.reposition();
            }
        },

        onDestroy: function() {

            var self = this;

            if (self.sub) {
                self.sub.$destroy();
                self.sub = null;
            }

            self.$super();
        },

        remove: function() {

            var self = this;

            if (self.sub) {
                self.sub.remove();
            }

            self.$super();
        }
    });
}());

